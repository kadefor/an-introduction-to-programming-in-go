# 3. 类型 Types

上一章我们用到了字符串（string）来存储 Hello World，数据类型(Data ty pes)是一组这样的值，他们被描述为能够在他们上的操作和定义了存储他们的方法。类型是一个很难掌握的概念，那么我们在看Go怎么实现他们之前，先从两个不同的视角看看听他们。

哲学家有时候会对类型和标识进行区分，例如，假设你有一只狗叫做Max，Max就是一个标识（一个特殊的实例或者成员），狗就是类型（通用的概念）。狗或者犬通常是被描述一组所有狗都共有属性的动物。我们可以简单地认为，所有狗都是有4条腿的，Max是一只狗，因此他有4条腿。在编程语言中的类型也类似这样，所有的字符串（string）都有一个长度（length），x是一个字符串，所有x也有长度。

在数学中我们经常谈论集合，例如，R（所有实数集合）和N（所有自然数集合）。这些集合中的成员和集合的其他成员共享属性，例如，所有自然数都是关联的，有自然数a,b,c，那么 a+(b+c)=(a+b)+c 和 a x (b x c)=(a x b) x c。在编程语言中也是类似的，一个特定的类型的所有值也是共享某些属性的。

Go 是一种静态类型的语言，即是说变量总是要指定一种类型，而且类型是不能改变的。静态类型看起来挺繁琐的，你需要花很多的时间来修复你的程序以便能够通过编译。但是类型能够帮助我们理解程序正在做什么，也能帮我们捕捉很多经常出现的错误。

Go 内置了很多数据类型，下面我们来逐一看看。

## Numbers（数字）

Go 有几种不同的类型类表示数字。通常我们会分成两类：整型和浮点型

#### Integers（整型）

Integers - 想他在数学里的表示一样，没有小数的数字，例如（-3, -2,0,1,..），计算机不是用我们常用的十进制来表示数字，而是用二进制。我们系统是由10个不同的数字组成，如果位数用满了，就进位来表示（译者：为什么从这么基础说起？），例如9的下一个数字是10，99的下一个数字是100等。计算机的做法是一样的，只是他只能有2个数字使用而不是10个，只有0和1，例如，0，1，10，11，100，101，110，111等等。

另一个不同是，计算机使用的 Integer 类型是有固定大小的，想一个4位（bit）整型可能是：0000,0001,0010,0100。

Go 的整型类型有：uint8, uint16,uint32,uint64,int8,int16,int32,int64，8,16,32和64告诉我们类型使用多少位，uint是"unsigned integer"（无符号整型），int是"signed integer"（带符号整型），无符号整型只包含正数和零，另外有两个别名的类型，byte 相同于 uint8，rune 相同于 uint32。字节（Bytes）在计算机上是非常通用的计算单元（1 byte=8 bits，1024 bytes=1 kilobyte，1024 kilobytes=1 megabyte，…），因此 Go 中的 byte 数据类型是经常用来定义其他类型。也有三个机器独立（不同的机器大小不一样）的整型：uint、int和uintptr，他们是机器独立的，他们的大小依赖于你使用的机器的架构。

通常，你是使用整型的时候都推荐使用 int 类型。

#### Floating Point Numbers（浮点型）

浮点数是一种包含小数的数字（实数）。例如，123.4、0.00001234，12340000等。他们再计算机的真实表现是非常复杂的，真的没有必要知道怎样用他们，因此我们必须记住：

* 浮点数是不精确的，偶尔他不可能表示一个数字，例如，计算 1.01 - 0.99的结果是 0.020000000000000018，这数字非常接近我们想要的结果，但却不是。
* 像整型一样，浮点数也有固定的大小（32位或者64位），使用较大的浮点数可以增加他的精度。（他表示有多少位数）
* 另外，数字能够表示位其他值，如“不是一个数字（not a number）”(NaN, 如 0/0)，无穷大的正数和负数。

Go 有两种浮点类型：float32 和 float64，通常被说成是单精度和双精度浮点数，还有两种附加的复数类型: complex64 和 complex128。通常，我们要使用浮点数，应该使用float64。

#### 实例

我们使用数字来写一个实例，首先创建一个 chapters 目录，在里面创建 main.go，文件内容包括：

	package main
	
	import "fmt"
	
	func main() {
		fmt.Println("1 + 1 =", 1 + 1)
	}

运行后如下：

	$ go run main.go
	1 + 1 = 2

注意，这里的实例和我们第二章写的非常相似，包含相同的包，相同的导入包，相同的函数声明和使用相同的 Println 函数，只是输入的内容不是 Hello World，而是 1 + 1 的结果。我们尝试使用浮点数：

	fmt.Println("1 + 1=", 1.0 + 1.0)

注意，这里的 .0 是要告诉 Go 这是一个浮点数，而不是整型数，运行这个出现会得到和之前一样的结果。

Go 也有其他的操作符：

	"+" 加
	"-" 减
	"8" 乘
	"/" 除
	"%" 取模

## Strings（字符串）

在第二章中，我们看到了，字符串是一组固定长度的字符队列，他用来表示文本。Go 的字符串是由独立的字节组成，通常是每个字符一个字节（其他语言的字符，例如中文，他可能需要多个字节）

字符串的字面值使用双引号来创建 "Hello World" 或者是反引号 \`Hello World\`。他们的区别是: 双引号字符串不能包含换行符，他们都允许特殊的转义队列. 例如，让我们来修改之前创建的 Hello World 实例：

	package main
	
	import "fmt"
	
	func main() {
		fmt.Println(len("Hello World"))
		fmt.Println("Hello World"[1])
		fmt.Println("Hello " + "World")
	}

有些事情要注意：

* 空格也是要正常的字符，所以字符串的长度是11而不是10，第三行使用"Hello " 代替 "Hello"
* 字符串的索引是以0开始而不是1，[1]就是第二个字符而不是第一个。也要注意的是运行程序后，你看到的是101而不是e，因为字符是通过字节(byte)来表示的（记住一个字节也是一个整型）。有另一种表示索引的方法："Hello World"1，也是表示第二个字符。
* 连接字符串使用和加好相同的符号+，Go 的编译器会根据参数的类型来决定怎么做，既然 + 两边都是字符串，那么编译器假设你的意思是连接而不是加法（加法对字符串是没有意义的）。

## Booleans（布尔型）

一个布尔型（被George Boole命名）是一个特殊的一位整型类型，用来表示 true 和 false（或者 on 和 off），布尔型可以使用3种逻辑操作符：

	&& and
	|| or
	!  not

下面一个实例来演示用法：

	func main() {
		fmt.Println(true && true)
		fmt.Println(true && false)
		fmt.Println(true || true)
		fmt.Println(true || false)
		fmt.Println(!true)
	}

运行后：

	$ go run main.go
	true
	false
	true
	true
	false

我们通常使用真值表来定义这些操作符：
	
	Expression		Value
	true && true	true
	true && false	false
	false && true	false
	false && false	false
	
	Expression		Value
	true || true	true
	true || false	true
	false || true	true
	false || false	false
	
	Expression		Value
	!true			false
	!false 			true

这些是 Go 里面最简单的类型，他们就是后面要讲的所有类型创建的基础。

## 问题

* 整型再计算机中如何存储？
* 我们知道十进制中，最大的一位数字是9，最大的2位数字是99，二进制最大的2位数字是11（3），最大的3位数字是111（7），最大的4位数字是15，那么最大的8位数字是什么？（提示：101-1 = 9， 102-1 = 99）
* 既然我们可以使用 Go 作为计算器，那么写一个程序，在终端输出 321325 x 424521（使用 * 操作符来做乘法）。
* 什么是字符串？怎么知道字符串的长度？
* 表达式 (true && false) || (false && true) || !(false && false) 的值是什么？

## 导航
* [目录](00.md)
* 上一章：[你的第一个程序](02.md)
* 下一章：[变量](04.md)
